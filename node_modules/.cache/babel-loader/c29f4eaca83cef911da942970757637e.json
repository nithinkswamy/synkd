{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport { WebPlugin } from './index';\nimport { FilesystemDirectory } from '../core-plugin-definitions';\nvar FilesystemPluginWeb = /** @class */function (_super) {\n  __extends(FilesystemPluginWeb, _super);\n  function FilesystemPluginWeb() {\n    var _this = _super.call(this, {\n      name: 'Filesystem',\n      platforms: ['web']\n    }) || this;\n    _this.DEFAULT_DIRECTORY = FilesystemDirectory.Data;\n    _this.DB_VERSION = 1;\n    _this.DB_NAME = 'Disc';\n    _this._writeCmds = ['add', 'put', 'delete'];\n    return _this;\n  }\n  FilesystemPluginWeb.prototype.initDb = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        if (this._db !== undefined) {\n          return [2 /*return*/, this._db];\n        }\n        if (!('indexedDB' in window)) {\n          throw new Error('This browser doesn\\'t support IndexedDB');\n        }\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var request = indexedDB.open(_this.DB_NAME, _this.DB_VERSION);\n          request.onupgradeneeded = FilesystemPluginWeb.doUpgrade;\n          request.onsuccess = function () {\n            _this._db = request.result;\n            resolve(request.result);\n          };\n          request.onerror = function () {\n            return reject(request.error);\n          };\n          request.onblocked = function () {\n            console.warn('db blocked');\n          };\n        })];\n      });\n    });\n  };\n  FilesystemPluginWeb.doUpgrade = function (event) {\n    var eventTarget = event.target;\n    var db = eventTarget.result;\n    switch (event.oldVersion) {\n      case 0:\n      case 1:\n      default:\n        if (db.objectStoreNames.contains('FileStorage')) {\n          db.deleteObjectStore('FileStorage');\n        }\n        var store = db.createObjectStore('FileStorage', {\n          keyPath: 'path'\n        });\n        store.createIndex('by_folder', 'folder');\n    }\n  };\n  FilesystemPluginWeb.prototype.dbRequest = function (cmd, args) {\n    return __awaiter(this, void 0, void 0, function () {\n      var readFlag;\n      return __generator(this, function (_a) {\n        readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n        return [2 /*return*/, this.initDb().then(function (conn) {\n          return new Promise(function (resolve, reject) {\n            var tx = conn.transaction(['FileStorage'], readFlag);\n            var store = tx.objectStore('FileStorage');\n            var req = store[cmd].apply(store, args);\n            req.onsuccess = function () {\n              return resolve(req.result);\n            };\n            req.onerror = function () {\n              return reject(req.error);\n            };\n          });\n        })];\n      });\n    });\n  };\n  FilesystemPluginWeb.prototype.dbIndexRequest = function (indexName, cmd, args) {\n    return __awaiter(this, void 0, void 0, function () {\n      var readFlag;\n      return __generator(this, function (_a) {\n        readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n        return [2 /*return*/, this.initDb().then(function (conn) {\n          return new Promise(function (resolve, reject) {\n            var tx = conn.transaction(['FileStorage'], readFlag);\n            var store = tx.objectStore('FileStorage');\n            var index = store.index(indexName);\n            var req = index[cmd].apply(index, args);\n            req.onsuccess = function () {\n              return resolve(req.result);\n            };\n            req.onerror = function () {\n              return reject(req.error);\n            };\n          });\n        })];\n      });\n    });\n  };\n  FilesystemPluginWeb.prototype.getPath = function (directory, uriPath) {\n    directory = directory || this.DEFAULT_DIRECTORY;\n    var cleanedUriPath = uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n    var fsPath = '/' + directory;\n    if (uriPath !== '') fsPath += '/' + cleanedUriPath;\n    return fsPath;\n  };\n  FilesystemPluginWeb.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var conn, tx, store;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.initDb()];\n          case 1:\n            conn = _a.sent();\n            tx = conn.transaction(['FileStorage'], 'readwrite');\n            store = tx.objectStore('FileStorage');\n            store.clear();\n            return [2 /*return*/, {}];\n        }\n      });\n    });\n  };\n  /**\n   * Read a file from disk\n   * @param options options for the file read\n   * @return a promise that resolves with the read file data result\n   */\n  FilesystemPluginWeb.prototype.readFile = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, entry;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            return [4 /*yield*/, this.dbRequest('get', [path])];\n          case 1:\n            entry = _a.sent();\n            if (entry === undefined) throw Error('File does not exist.');\n            return [2 /*return*/, {\n              data: entry.content\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Write a file to disk in the specified location on device\n   * @param options options for the file write\n   * @return a promise that resolves with the file write result\n   */\n  FilesystemPluginWeb.prototype.writeFile = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, data, doRecursive, occupiedEntry, encoding, parentPath, parentEntry, subDirIndex, parentArgPath, now, pathObj;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            data = options.data;\n            doRecursive = options.recursive;\n            return [4 /*yield*/, this.dbRequest('get', [path])];\n          case 1:\n            occupiedEntry = _a.sent();\n            if (occupiedEntry && occupiedEntry.type === 'directory') throw 'The supplied path is a directory.';\n            encoding = options.encoding;\n            parentPath = path.substr(0, path.lastIndexOf('/'));\n            return [4 /*yield*/, this.dbRequest('get', [parentPath])];\n          case 2:\n            parentEntry = _a.sent();\n            if (!(parentEntry === undefined)) return [3 /*break*/, 4];\n            subDirIndex = parentPath.indexOf('/', 1);\n            if (!(subDirIndex !== -1)) return [3 /*break*/, 4];\n            parentArgPath = parentPath.substr(subDirIndex);\n            return [4 /*yield*/, this.mkdir({\n              path: parentArgPath,\n              directory: options.directory,\n              recursive: doRecursive\n            })];\n          case 3:\n            _a.sent();\n            _a.label = 4;\n          case 4:\n            now = Date.now();\n            pathObj = {\n              path: path,\n              folder: parentPath,\n              type: 'file',\n              size: data.length,\n              ctime: now,\n              mtime: now,\n              content: !encoding && data.indexOf(',') >= 0 ? data.split(',')[1] : data\n            };\n            return [4 /*yield*/, this.dbRequest('put', [pathObj])];\n          case 5:\n            _a.sent();\n            return [2 /*return*/, {\n              uri: pathObj.path\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Append to a file on disk in the specified location on device\n   * @param options options for the file append\n   * @return a promise that resolves with the file write result\n   */\n  FilesystemPluginWeb.prototype.appendFile = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, data, parentPath, now, ctime, occupiedEntry, parentEntry, subDirIndex, parentArgPath, pathObj;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            data = options.data;\n            parentPath = path.substr(0, path.lastIndexOf('/'));\n            now = Date.now();\n            ctime = now;\n            return [4 /*yield*/, this.dbRequest('get', [path])];\n          case 1:\n            occupiedEntry = _a.sent();\n            if (occupiedEntry && occupiedEntry.type === 'directory') throw 'The supplied path is a directory.';\n            return [4 /*yield*/, this.dbRequest('get', [parentPath])];\n          case 2:\n            parentEntry = _a.sent();\n            if (!(parentEntry === undefined)) return [3 /*break*/, 4];\n            subDirIndex = parentPath.indexOf('/', 1);\n            if (!(subDirIndex !== -1)) return [3 /*break*/, 4];\n            parentArgPath = parentPath.substr(subDirIndex);\n            return [4 /*yield*/, this.mkdir({\n              path: parentArgPath,\n              directory: options.directory,\n              recursive: true\n            })];\n          case 3:\n            _a.sent();\n            _a.label = 4;\n          case 4:\n            if (occupiedEntry !== undefined) {\n              data = occupiedEntry.content + data;\n              ctime = occupiedEntry.ctime;\n            }\n            pathObj = {\n              path: path,\n              folder: parentPath,\n              type: 'file',\n              size: data.length,\n              ctime: ctime,\n              mtime: now,\n              content: data\n            };\n            return [4 /*yield*/, this.dbRequest('put', [pathObj])];\n          case 5:\n            _a.sent();\n            return [2 /*return*/, {}];\n        }\n      });\n    });\n  };\n  /**\n   * Delete a file from disk\n   * @param options options for the file delete\n   * @return a promise that resolves with the deleted file data result\n   */\n  FilesystemPluginWeb.prototype.deleteFile = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, entry, entries;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            return [4 /*yield*/, this.dbRequest('get', [path])];\n          case 1:\n            entry = _a.sent();\n            if (entry === undefined) throw Error('File does not exist.');\n            return [4 /*yield*/, this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)])];\n          case 2:\n            entries = _a.sent();\n            if (entries.length !== 0) throw Error('Folder is not empty.');\n            return [4 /*yield*/, this.dbRequest('delete', [path])];\n          case 3:\n            _a.sent();\n            return [2 /*return*/, {}];\n        }\n      });\n    });\n  };\n  /**\n   * Create a directory.\n   * @param options options for the mkdir\n   * @return a promise that resolves with the mkdir result\n   */\n  FilesystemPluginWeb.prototype.mkdir = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, doRecursive, parentPath, depth, parentEntry, occupiedEntry, parentArgPath, now, pathObj;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            doRecursive = options.recursive;\n            parentPath = path.substr(0, path.lastIndexOf('/'));\n            depth = (path.match(/\\//g) || []).length;\n            return [4 /*yield*/, this.dbRequest('get', [parentPath])];\n          case 1:\n            parentEntry = _a.sent();\n            return [4 /*yield*/, this.dbRequest('get', [path])];\n          case 2:\n            occupiedEntry = _a.sent();\n            if (depth === 1) throw Error('Cannot create Root directory');\n            if (occupiedEntry !== undefined) throw Error('Current directory does already exist.');\n            if (!doRecursive && depth !== 2 && parentEntry === undefined) throw Error('Parent directory must exist');\n            if (!(doRecursive && depth !== 2 && parentEntry === undefined)) return [3 /*break*/, 4];\n            parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n            return [4 /*yield*/, this.mkdir({\n              path: parentArgPath,\n              directory: options.directory,\n              recursive: doRecursive\n            })];\n          case 3:\n            _a.sent();\n            _a.label = 4;\n          case 4:\n            now = Date.now();\n            pathObj = {\n              path: path,\n              folder: parentPath,\n              type: 'directory',\n              size: 0,\n              ctime: now,\n              mtime: now\n            };\n            return [4 /*yield*/, this.dbRequest('put', [pathObj])];\n          case 5:\n            _a.sent();\n            return [2 /*return*/, {}];\n        }\n      });\n    });\n  };\n  /**\n   * Remove a directory\n   * @param options the options for the directory remove\n   */\n  FilesystemPluginWeb.prototype.rmdir = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, directory, recursive, fullPath, entry, readDirResult, _i, _a, entry_1, entryPath, entryObj;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            path = options.path, directory = options.directory, recursive = options.recursive;\n            fullPath = this.getPath(directory, path);\n            return [4 /*yield*/, this.dbRequest('get', [fullPath])];\n          case 1:\n            entry = _b.sent();\n            if (entry === undefined) throw Error('Folder does not exist.');\n            if (entry.type !== 'directory') throw Error('Requested path is not a directory');\n            return [4 /*yield*/, this.readdir({\n              path: path,\n              directory: directory\n            })];\n          case 2:\n            readDirResult = _b.sent();\n            if (readDirResult.files.length !== 0 && !recursive) throw Error('Folder is not empty');\n            _i = 0, _a = readDirResult.files;\n            _b.label = 3;\n          case 3:\n            if (!(_i < _a.length)) return [3 /*break*/, 9];\n            entry_1 = _a[_i];\n            entryPath = path + \"/\" + entry_1;\n            return [4 /*yield*/, this.stat({\n              path: entryPath,\n              directory: directory\n            })];\n          case 4:\n            entryObj = _b.sent();\n            if (!(entryObj.type === 'file')) return [3 /*break*/, 6];\n            return [4 /*yield*/, this.deleteFile({\n              path: entryPath,\n              directory: directory\n            })];\n          case 5:\n            _b.sent();\n            return [3 /*break*/, 8];\n          case 6:\n            return [4 /*yield*/, this.rmdir({\n              path: entryPath,\n              directory: directory,\n              recursive: recursive\n            })];\n          case 7:\n            _b.sent();\n            _b.label = 8;\n          case 8:\n            _i++;\n            return [3 /*break*/, 3];\n          case 9:\n            return [4 /*yield*/, this.dbRequest('delete', [fullPath])];\n          case 10:\n            _b.sent();\n            return [2 /*return*/, {}];\n        }\n      });\n    });\n  };\n  /**\n   * Return a list of files from the directory (not recursive)\n   * @param options the options for the readdir operation\n   * @return a promise that resolves with the readdir directory listing result\n   */\n  FilesystemPluginWeb.prototype.readdir = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, entry, entries, names;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            return [4 /*yield*/, this.dbRequest('get', [path])];\n          case 1:\n            entry = _a.sent();\n            if (options.path !== '' && entry === undefined) throw Error('Folder does not exist.');\n            return [4 /*yield*/, this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)])];\n          case 2:\n            entries = _a.sent();\n            names = entries.map(function (e) {\n              return e.substring(path.length + 1);\n            });\n            return [2 /*return*/, {\n              files: names\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Return full File URI for a path and directory\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  FilesystemPluginWeb.prototype.getUri = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, entry;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            return [4 /*yield*/, this.dbRequest('get', [path])];\n          case 1:\n            entry = _a.sent();\n            if (!(entry === undefined)) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.dbRequest('get', [path + '/'])];\n          case 2:\n            entry = _a.sent();\n            _a.label = 3;\n          case 3:\n            if (entry === undefined) throw Error('Entry does not exist.');\n            return [2 /*return*/, {\n              uri: entry.path\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Return data about a file\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  FilesystemPluginWeb.prototype.stat = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var path, entry;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            path = this.getPath(options.directory, options.path);\n            return [4 /*yield*/, this.dbRequest('get', [path])];\n          case 1:\n            entry = _a.sent();\n            if (!(entry === undefined)) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.dbRequest('get', [path + '/'])];\n          case 2:\n            entry = _a.sent();\n            _a.label = 3;\n          case 3:\n            if (entry === undefined) throw Error('Entry does not exist.');\n            return [2 /*return*/, {\n              type: entry.type,\n              size: entry.size,\n              ctime: entry.ctime,\n              mtime: entry.mtime,\n              uri: entry.path\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Rename a file or directory\n   * @param options the options for the rename operation\n   * @return a promise that resolves with the rename result\n   */\n  FilesystemPluginWeb.prototype.rename = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this._copy(options, true)];\n      });\n    });\n  };\n  /**\n   * Copy a file or directory\n   * @param options the options for the copy operation\n   * @return a promise that resolves with the copy result\n   */\n  FilesystemPluginWeb.prototype.copy = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this._copy(options, false)];\n      });\n    });\n  };\n  /**\n   * Function that can perform a copy or a rename\n   * @param options the options for the rename operation\n   * @param doRename whether to perform a rename or copy operation\n   * @return a promise that resolves with the result\n   */\n  FilesystemPluginWeb.prototype._copy = function (options, doRename) {\n    if (doRename === void 0) {\n      doRename = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var to, from, fromDirectory, toDirectory, fromPath, toPath, toObj, e_1, toPathComponents, toPath_1, toParentDirectory, fromObj, updateTime, _a, file, e_2, contents, _i, contents_1, filename;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            to = options.to, from = options.from, fromDirectory = options.directory, toDirectory = options.toDirectory;\n            if (!to || !from) {\n              throw Error('Both to and from must be provided');\n            }\n            // If no \"to\" directory is provided, use the \"from\" directory\n            if (!toDirectory) {\n              toDirectory = fromDirectory;\n            }\n            fromPath = this.getPath(fromDirectory, from);\n            toPath = this.getPath(toDirectory, to);\n            // Test that the \"to\" and \"from\" locations are different\n            if (fromPath === toPath) {\n              return [2 /*return*/, {}];\n            }\n            if (toPath.startsWith(fromPath)) {\n              throw Error('To path cannot contain the from path');\n            }\n            _b.label = 1;\n          case 1:\n            _b.trys.push([1, 3,, 6]);\n            return [4 /*yield*/, this.stat({\n              path: to,\n              directory: toDirectory\n            })];\n          case 2:\n            toObj = _b.sent();\n            return [3 /*break*/, 6];\n          case 3:\n            e_1 = _b.sent();\n            toPathComponents = to.split('/');\n            toPathComponents.pop();\n            toPath_1 = toPathComponents.join('/');\n            if (!(toPathComponents.length > 0)) return [3 /*break*/, 5];\n            return [4 /*yield*/, this.stat({\n              path: toPath_1,\n              directory: toDirectory\n            })];\n          case 4:\n            toParentDirectory = _b.sent();\n            if (toParentDirectory.type !== 'directory') {\n              throw new Error('Parent directory of the to path is a file');\n            }\n            _b.label = 5;\n          case 5:\n            return [3 /*break*/, 6];\n          case 6:\n            // Cannot overwrite a directory\n            if (toObj && toObj.type === 'directory') {\n              throw new Error('Cannot overwrite a directory with a file');\n            }\n            return [4 /*yield*/, this.stat({\n              path: from,\n              directory: fromDirectory\n            })];\n          case 7:\n            fromObj = _b.sent();\n            updateTime = function (path, ctime, mtime) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var fullPath, entry;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      fullPath = this.getPath(toDirectory, path);\n                      return [4 /*yield*/, this.dbRequest('get', [fullPath])];\n                    case 1:\n                      entry = _a.sent();\n                      entry.ctime = ctime;\n                      entry.mtime = mtime;\n                      return [4 /*yield*/, this.dbRequest('put', [entry])];\n                    case 2:\n                      _a.sent();\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            };\n\n            _a = fromObj.type;\n            switch (_a) {\n              case 'file':\n                return [3 /*break*/, 8];\n              case 'directory':\n                return [3 /*break*/, 15];\n            }\n            return [3 /*break*/, 28];\n          case 8:\n            return [4 /*yield*/, this.readFile({\n              path: from,\n              directory: fromDirectory\n            })];\n          case 9:\n            file = _b.sent();\n            if (!doRename) return [3 /*break*/, 11];\n            return [4 /*yield*/, this.deleteFile({\n              path: from,\n              directory: fromDirectory\n            })];\n          case 10:\n            _b.sent();\n            _b.label = 11;\n          case 11:\n            // Write the file to the new location\n            return [4 /*yield*/, this.writeFile({\n              path: to,\n              directory: toDirectory,\n              data: file.data\n            })];\n          case 12:\n            // Write the file to the new location\n            _b.sent();\n            if (!doRename) return [3 /*break*/, 14];\n            return [4 /*yield*/, updateTime(to, fromObj.ctime, fromObj.mtime)];\n          case 13:\n            _b.sent();\n            _b.label = 14;\n          case 14:\n            // Resolve promise\n            return [2 /*return*/, {}];\n          case 15:\n            if (toObj) {\n              throw Error('Cannot move a directory over an existing object');\n            }\n            _b.label = 16;\n          case 16:\n            _b.trys.push([16, 20,, 21]);\n            // Create the to directory\n            return [4 /*yield*/, this.mkdir({\n              path: to,\n              directory: toDirectory,\n              recursive: false\n            })];\n          case 17:\n            // Create the to directory\n            _b.sent();\n            if (!doRename) return [3 /*break*/, 19];\n            return [4 /*yield*/, updateTime(to, fromObj.ctime, fromObj.mtime)];\n          case 18:\n            _b.sent();\n            _b.label = 19;\n          case 19:\n            return [3 /*break*/, 21];\n          case 20:\n            e_2 = _b.sent();\n            return [3 /*break*/, 21];\n          case 21:\n            return [4 /*yield*/, this.readdir({\n              path: from,\n              directory: fromDirectory\n            })];\n          case 22:\n            contents = _b.sent().files;\n            _i = 0, contents_1 = contents;\n            _b.label = 23;\n          case 23:\n            if (!(_i < contents_1.length)) return [3 /*break*/, 26];\n            filename = contents_1[_i];\n            // Move item from the from directory to the to directory\n            return [4 /*yield*/, this._copy({\n              from: from + \"/\" + filename,\n              to: to + \"/\" + filename,\n              directory: fromDirectory,\n              toDirectory: toDirectory\n            }, doRename)];\n          case 24:\n            // Move item from the from directory to the to directory\n            _b.sent();\n            _b.label = 25;\n          case 25:\n            _i++;\n            return [3 /*break*/, 23];\n          case 26:\n            if (!doRename) return [3 /*break*/, 28];\n            return [4 /*yield*/, this.rmdir({\n              path: from,\n              directory: fromDirectory\n            })];\n          case 27:\n            _b.sent();\n            _b.label = 28;\n          case 28:\n            return [2 /*return*/, {}];\n        }\n      });\n    });\n  };\n  FilesystemPluginWeb._debug = true;\n  return FilesystemPluginWeb;\n}(WebPlugin);\nexport { FilesystemPluginWeb };\nvar Filesystem = new FilesystemPluginWeb();\nexport { Filesystem };","map":{"version":3,"sources":["../../../src/web/filesystem.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __extends, __generator } from \"tslib\";\nimport { WebPlugin } from './index';\nimport { FilesystemDirectory } from '../core-plugin-definitions';\nvar FilesystemPluginWeb = /** @class */ (function (_super) {\n    __extends(FilesystemPluginWeb, _super);\n    function FilesystemPluginWeb() {\n        var _this = _super.call(this, {\n            name: 'Filesystem',\n            platforms: ['web']\n        }) || this;\n        _this.DEFAULT_DIRECTORY = FilesystemDirectory.Data;\n        _this.DB_VERSION = 1;\n        _this.DB_NAME = 'Disc';\n        _this._writeCmds = ['add', 'put', 'delete'];\n        return _this;\n    }\n    FilesystemPluginWeb.prototype.initDb = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                if (this._db !== undefined) {\n                    return [2 /*return*/, this._db];\n                }\n                if (!('indexedDB' in window)) {\n                    throw new Error('This browser doesn\\'t support IndexedDB');\n                }\n                return [2 /*return*/, new Promise(function (resolve, reject) {\n                        var request = indexedDB.open(_this.DB_NAME, _this.DB_VERSION);\n                        request.onupgradeneeded = FilesystemPluginWeb.doUpgrade;\n                        request.onsuccess = function () {\n                            _this._db = request.result;\n                            resolve(request.result);\n                        };\n                        request.onerror = function () { return reject(request.error); };\n                        request.onblocked = function () {\n                            console.warn('db blocked');\n                        };\n                    })];\n            });\n        });\n    };\n    FilesystemPluginWeb.doUpgrade = function (event) {\n        var eventTarget = event.target;\n        var db = eventTarget.result;\n        switch (event.oldVersion) {\n            case 0:\n            case 1:\n            default:\n                if (db.objectStoreNames.contains('FileStorage')) {\n                    db.deleteObjectStore('FileStorage');\n                }\n                var store = db.createObjectStore('FileStorage', { keyPath: 'path' });\n                store.createIndex('by_folder', 'folder');\n        }\n    };\n    FilesystemPluginWeb.prototype.dbRequest = function (cmd, args) {\n        return __awaiter(this, void 0, void 0, function () {\n            var readFlag;\n            return __generator(this, function (_a) {\n                readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n                return [2 /*return*/, this.initDb()\n                        .then(function (conn) {\n                        return new Promise(function (resolve, reject) {\n                            var tx = conn.transaction(['FileStorage'], readFlag);\n                            var store = tx.objectStore('FileStorage');\n                            var req = store[cmd].apply(store, args);\n                            req.onsuccess = function () { return resolve(req.result); };\n                            req.onerror = function () { return reject(req.error); };\n                        });\n                    })];\n            });\n        });\n    };\n    FilesystemPluginWeb.prototype.dbIndexRequest = function (indexName, cmd, args) {\n        return __awaiter(this, void 0, void 0, function () {\n            var readFlag;\n            return __generator(this, function (_a) {\n                readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n                return [2 /*return*/, this.initDb()\n                        .then(function (conn) {\n                        return new Promise(function (resolve, reject) {\n                            var tx = conn.transaction(['FileStorage'], readFlag);\n                            var store = tx.objectStore('FileStorage');\n                            var index = store.index(indexName);\n                            var req = index[cmd].apply(index, args);\n                            req.onsuccess = function () { return resolve(req.result); };\n                            req.onerror = function () { return reject(req.error); };\n                        });\n                    })];\n            });\n        });\n    };\n    FilesystemPluginWeb.prototype.getPath = function (directory, uriPath) {\n        directory = directory || this.DEFAULT_DIRECTORY;\n        var cleanedUriPath = uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n        var fsPath = '/' + directory;\n        if (uriPath !== '')\n            fsPath += '/' + cleanedUriPath;\n        return fsPath;\n    };\n    FilesystemPluginWeb.prototype.clear = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var conn, tx, store;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.initDb()];\n                    case 1:\n                        conn = _a.sent();\n                        tx = conn.transaction(['FileStorage'], 'readwrite');\n                        store = tx.objectStore('FileStorage');\n                        store.clear();\n                        return [2 /*return*/, {}];\n                }\n            });\n        });\n    };\n    /**\n     * Read a file from disk\n     * @param options options for the file read\n     * @return a promise that resolves with the read file data result\n     */\n    FilesystemPluginWeb.prototype.readFile = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, entry;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 1:\n                        entry = _a.sent();\n                        if (entry === undefined)\n                            throw Error('File does not exist.');\n                        return [2 /*return*/, { data: entry.content }];\n                }\n            });\n        });\n    };\n    /**\n     * Write a file to disk in the specified location on device\n     * @param options options for the file write\n     * @return a promise that resolves with the file write result\n     */\n    FilesystemPluginWeb.prototype.writeFile = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, data, doRecursive, occupiedEntry, encoding, parentPath, parentEntry, subDirIndex, parentArgPath, now, pathObj;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        data = options.data;\n                        doRecursive = options.recursive;\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 1:\n                        occupiedEntry = _a.sent();\n                        if (occupiedEntry && occupiedEntry.type === 'directory')\n                            throw ('The supplied path is a directory.');\n                        encoding = options.encoding;\n                        parentPath = path.substr(0, path.lastIndexOf('/'));\n                        return [4 /*yield*/, this.dbRequest('get', [parentPath])];\n                    case 2:\n                        parentEntry = _a.sent();\n                        if (!(parentEntry === undefined)) return [3 /*break*/, 4];\n                        subDirIndex = parentPath.indexOf('/', 1);\n                        if (!(subDirIndex !== -1)) return [3 /*break*/, 4];\n                        parentArgPath = parentPath.substr(subDirIndex);\n                        return [4 /*yield*/, this.mkdir({ path: parentArgPath, directory: options.directory, recursive: doRecursive })];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4:\n                        now = Date.now();\n                        pathObj = {\n                            path: path,\n                            folder: parentPath,\n                            type: 'file',\n                            size: data.length,\n                            ctime: now,\n                            mtime: now,\n                            content: !encoding && data.indexOf(',') >= 0 ? data.split(',')[1] : data,\n                        };\n                        return [4 /*yield*/, this.dbRequest('put', [pathObj])];\n                    case 5:\n                        _a.sent();\n                        return [2 /*return*/, {\n                                uri: pathObj.path\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Append to a file on disk in the specified location on device\n     * @param options options for the file append\n     * @return a promise that resolves with the file write result\n     */\n    FilesystemPluginWeb.prototype.appendFile = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, data, parentPath, now, ctime, occupiedEntry, parentEntry, subDirIndex, parentArgPath, pathObj;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        data = options.data;\n                        parentPath = path.substr(0, path.lastIndexOf('/'));\n                        now = Date.now();\n                        ctime = now;\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 1:\n                        occupiedEntry = _a.sent();\n                        if (occupiedEntry && occupiedEntry.type === 'directory')\n                            throw ('The supplied path is a directory.');\n                        return [4 /*yield*/, this.dbRequest('get', [parentPath])];\n                    case 2:\n                        parentEntry = _a.sent();\n                        if (!(parentEntry === undefined)) return [3 /*break*/, 4];\n                        subDirIndex = parentPath.indexOf('/', 1);\n                        if (!(subDirIndex !== -1)) return [3 /*break*/, 4];\n                        parentArgPath = parentPath.substr(subDirIndex);\n                        return [4 /*yield*/, this.mkdir({ path: parentArgPath, directory: options.directory, recursive: true })];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4:\n                        if (occupiedEntry !== undefined) {\n                            data = occupiedEntry.content + data;\n                            ctime = occupiedEntry.ctime;\n                        }\n                        pathObj = {\n                            path: path,\n                            folder: parentPath,\n                            type: 'file',\n                            size: data.length,\n                            ctime: ctime,\n                            mtime: now,\n                            content: data\n                        };\n                        return [4 /*yield*/, this.dbRequest('put', [pathObj])];\n                    case 5:\n                        _a.sent();\n                        return [2 /*return*/, {}];\n                }\n            });\n        });\n    };\n    /**\n     * Delete a file from disk\n     * @param options options for the file delete\n     * @return a promise that resolves with the deleted file data result\n     */\n    FilesystemPluginWeb.prototype.deleteFile = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, entry, entries;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 1:\n                        entry = _a.sent();\n                        if (entry === undefined)\n                            throw Error('File does not exist.');\n                        return [4 /*yield*/, this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)])];\n                    case 2:\n                        entries = _a.sent();\n                        if (entries.length !== 0)\n                            throw Error('Folder is not empty.');\n                        return [4 /*yield*/, this.dbRequest('delete', [path])];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/, {}];\n                }\n            });\n        });\n    };\n    /**\n     * Create a directory.\n     * @param options options for the mkdir\n     * @return a promise that resolves with the mkdir result\n     */\n    FilesystemPluginWeb.prototype.mkdir = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, doRecursive, parentPath, depth, parentEntry, occupiedEntry, parentArgPath, now, pathObj;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        doRecursive = options.recursive;\n                        parentPath = path.substr(0, path.lastIndexOf('/'));\n                        depth = (path.match(/\\//g) || []).length;\n                        return [4 /*yield*/, this.dbRequest('get', [parentPath])];\n                    case 1:\n                        parentEntry = _a.sent();\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 2:\n                        occupiedEntry = _a.sent();\n                        if (depth === 1)\n                            throw Error('Cannot create Root directory');\n                        if (occupiedEntry !== undefined)\n                            throw Error('Current directory does already exist.');\n                        if (!doRecursive && depth !== 2 && parentEntry === undefined)\n                            throw Error('Parent directory must exist');\n                        if (!(doRecursive && depth !== 2 && parentEntry === undefined)) return [3 /*break*/, 4];\n                        parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n                        return [4 /*yield*/, this.mkdir({\n                                path: parentArgPath,\n                                directory: options.directory,\n                                recursive: doRecursive\n                            })];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4:\n                        now = Date.now();\n                        pathObj = { path: path, folder: parentPath, type: 'directory', size: 0, ctime: now, mtime: now };\n                        return [4 /*yield*/, this.dbRequest('put', [pathObj])];\n                    case 5:\n                        _a.sent();\n                        return [2 /*return*/, {}];\n                }\n            });\n        });\n    };\n    /**\n     * Remove a directory\n     * @param options the options for the directory remove\n     */\n    FilesystemPluginWeb.prototype.rmdir = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, directory, recursive, fullPath, entry, readDirResult, _i, _a, entry_1, entryPath, entryObj;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        path = options.path, directory = options.directory, recursive = options.recursive;\n                        fullPath = this.getPath(directory, path);\n                        return [4 /*yield*/, this.dbRequest('get', [fullPath])];\n                    case 1:\n                        entry = _b.sent();\n                        if (entry === undefined)\n                            throw Error('Folder does not exist.');\n                        if (entry.type !== 'directory')\n                            throw Error('Requested path is not a directory');\n                        return [4 /*yield*/, this.readdir({ path: path, directory: directory })];\n                    case 2:\n                        readDirResult = _b.sent();\n                        if (readDirResult.files.length !== 0 && !recursive)\n                            throw Error('Folder is not empty');\n                        _i = 0, _a = readDirResult.files;\n                        _b.label = 3;\n                    case 3:\n                        if (!(_i < _a.length)) return [3 /*break*/, 9];\n                        entry_1 = _a[_i];\n                        entryPath = path + \"/\" + entry_1;\n                        return [4 /*yield*/, this.stat({ path: entryPath, directory: directory })];\n                    case 4:\n                        entryObj = _b.sent();\n                        if (!(entryObj.type === 'file')) return [3 /*break*/, 6];\n                        return [4 /*yield*/, this.deleteFile({ path: entryPath, directory: directory })];\n                    case 5:\n                        _b.sent();\n                        return [3 /*break*/, 8];\n                    case 6: return [4 /*yield*/, this.rmdir({ path: entryPath, directory: directory, recursive: recursive })];\n                    case 7:\n                        _b.sent();\n                        _b.label = 8;\n                    case 8:\n                        _i++;\n                        return [3 /*break*/, 3];\n                    case 9: return [4 /*yield*/, this.dbRequest('delete', [fullPath])];\n                    case 10:\n                        _b.sent();\n                        return [2 /*return*/, {}];\n                }\n            });\n        });\n    };\n    /**\n     * Return a list of files from the directory (not recursive)\n     * @param options the options for the readdir operation\n     * @return a promise that resolves with the readdir directory listing result\n     */\n    FilesystemPluginWeb.prototype.readdir = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, entry, entries, names;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 1:\n                        entry = _a.sent();\n                        if (options.path !== '' && entry === undefined)\n                            throw Error('Folder does not exist.');\n                        return [4 /*yield*/, this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)])];\n                    case 2:\n                        entries = _a.sent();\n                        names = entries.map(function (e) {\n                            return e.substring(path.length + 1);\n                        });\n                        return [2 /*return*/, { files: names }];\n                }\n            });\n        });\n    };\n    /**\n     * Return full File URI for a path and directory\n     * @param options the options for the stat operation\n     * @return a promise that resolves with the file stat result\n     */\n    FilesystemPluginWeb.prototype.getUri = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, entry;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 1:\n                        entry = _a.sent();\n                        if (!(entry === undefined)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.dbRequest('get', [path + '/'])];\n                    case 2:\n                        entry = (_a.sent());\n                        _a.label = 3;\n                    case 3:\n                        if (entry === undefined)\n                            throw Error('Entry does not exist.');\n                        return [2 /*return*/, {\n                                uri: entry.path\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Return data about a file\n     * @param options the options for the stat operation\n     * @return a promise that resolves with the file stat result\n     */\n    FilesystemPluginWeb.prototype.stat = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var path, entry;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        path = this.getPath(options.directory, options.path);\n                        return [4 /*yield*/, this.dbRequest('get', [path])];\n                    case 1:\n                        entry = _a.sent();\n                        if (!(entry === undefined)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.dbRequest('get', [path + '/'])];\n                    case 2:\n                        entry = (_a.sent());\n                        _a.label = 3;\n                    case 3:\n                        if (entry === undefined)\n                            throw Error('Entry does not exist.');\n                        return [2 /*return*/, {\n                                type: entry.type,\n                                size: entry.size,\n                                ctime: entry.ctime,\n                                mtime: entry.mtime,\n                                uri: entry.path\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Rename a file or directory\n     * @param options the options for the rename operation\n     * @return a promise that resolves with the rename result\n     */\n    FilesystemPluginWeb.prototype.rename = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this._copy(options, true)];\n            });\n        });\n    };\n    /**\n     * Copy a file or directory\n     * @param options the options for the copy operation\n     * @return a promise that resolves with the copy result\n     */\n    FilesystemPluginWeb.prototype.copy = function (options) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this._copy(options, false)];\n            });\n        });\n    };\n    /**\n     * Function that can perform a copy or a rename\n     * @param options the options for the rename operation\n     * @param doRename whether to perform a rename or copy operation\n     * @return a promise that resolves with the result\n     */\n    FilesystemPluginWeb.prototype._copy = function (options, doRename) {\n        if (doRename === void 0) { doRename = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var to, from, fromDirectory, toDirectory, fromPath, toPath, toObj, e_1, toPathComponents, toPath_1, toParentDirectory, fromObj, updateTime, _a, file, e_2, contents, _i, contents_1, filename;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        to = options.to, from = options.from, fromDirectory = options.directory, toDirectory = options.toDirectory;\n                        if (!to || !from) {\n                            throw Error('Both to and from must be provided');\n                        }\n                        // If no \"to\" directory is provided, use the \"from\" directory\n                        if (!toDirectory) {\n                            toDirectory = fromDirectory;\n                        }\n                        fromPath = this.getPath(fromDirectory, from);\n                        toPath = this.getPath(toDirectory, to);\n                        // Test that the \"to\" and \"from\" locations are different\n                        if (fromPath === toPath) {\n                            return [2 /*return*/, {}];\n                        }\n                        if (toPath.startsWith(fromPath)) {\n                            throw Error('To path cannot contain the from path');\n                        }\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 3, , 6]);\n                        return [4 /*yield*/, this.stat({\n                                path: to,\n                                directory: toDirectory\n                            })];\n                    case 2:\n                        toObj = _b.sent();\n                        return [3 /*break*/, 6];\n                    case 3:\n                        e_1 = _b.sent();\n                        toPathComponents = to.split('/');\n                        toPathComponents.pop();\n                        toPath_1 = toPathComponents.join('/');\n                        if (!(toPathComponents.length > 0)) return [3 /*break*/, 5];\n                        return [4 /*yield*/, this.stat({\n                                path: toPath_1,\n                                directory: toDirectory,\n                            })];\n                    case 4:\n                        toParentDirectory = _b.sent();\n                        if (toParentDirectory.type !== 'directory') {\n                            throw new Error('Parent directory of the to path is a file');\n                        }\n                        _b.label = 5;\n                    case 5: return [3 /*break*/, 6];\n                    case 6:\n                        // Cannot overwrite a directory\n                        if (toObj && toObj.type === 'directory') {\n                            throw new Error('Cannot overwrite a directory with a file');\n                        }\n                        return [4 /*yield*/, this.stat({\n                                path: from,\n                                directory: fromDirectory,\n                            })];\n                    case 7:\n                        fromObj = _b.sent();\n                        updateTime = function (path, ctime, mtime) { return __awaiter(_this, void 0, void 0, function () {\n                            var fullPath, entry;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        fullPath = this.getPath(toDirectory, path);\n                                        return [4 /*yield*/, this.dbRequest('get', [fullPath])];\n                                    case 1:\n                                        entry = _a.sent();\n                                        entry.ctime = ctime;\n                                        entry.mtime = mtime;\n                                        return [4 /*yield*/, this.dbRequest('put', [entry])];\n                                    case 2:\n                                        _a.sent();\n                                        return [2 /*return*/];\n                                }\n                            });\n                        }); };\n                        _a = fromObj.type;\n                        switch (_a) {\n                            case 'file': return [3 /*break*/, 8];\n                            case 'directory': return [3 /*break*/, 15];\n                        }\n                        return [3 /*break*/, 28];\n                    case 8: return [4 /*yield*/, this.readFile({\n                            path: from,\n                            directory: fromDirectory\n                        })];\n                    case 9:\n                        file = _b.sent();\n                        if (!doRename) return [3 /*break*/, 11];\n                        return [4 /*yield*/, this.deleteFile({\n                                path: from,\n                                directory: fromDirectory\n                            })];\n                    case 10:\n                        _b.sent();\n                        _b.label = 11;\n                    case 11: \n                    // Write the file to the new location\n                    return [4 /*yield*/, this.writeFile({\n                            path: to,\n                            directory: toDirectory,\n                            data: file.data\n                        })];\n                    case 12:\n                        // Write the file to the new location\n                        _b.sent();\n                        if (!doRename) return [3 /*break*/, 14];\n                        return [4 /*yield*/, updateTime(to, fromObj.ctime, fromObj.mtime)];\n                    case 13:\n                        _b.sent();\n                        _b.label = 14;\n                    case 14: \n                    // Resolve promise\n                    return [2 /*return*/, {}];\n                    case 15:\n                        if (toObj) {\n                            throw Error('Cannot move a directory over an existing object');\n                        }\n                        _b.label = 16;\n                    case 16:\n                        _b.trys.push([16, 20, , 21]);\n                        // Create the to directory\n                        return [4 /*yield*/, this.mkdir({\n                                path: to,\n                                directory: toDirectory,\n                                recursive: false,\n                            })];\n                    case 17:\n                        // Create the to directory\n                        _b.sent();\n                        if (!doRename) return [3 /*break*/, 19];\n                        return [4 /*yield*/, updateTime(to, fromObj.ctime, fromObj.mtime)];\n                    case 18:\n                        _b.sent();\n                        _b.label = 19;\n                    case 19: return [3 /*break*/, 21];\n                    case 20:\n                        e_2 = _b.sent();\n                        return [3 /*break*/, 21];\n                    case 21: return [4 /*yield*/, this.readdir({\n                            path: from,\n                            directory: fromDirectory,\n                        })];\n                    case 22:\n                        contents = (_b.sent()).files;\n                        _i = 0, contents_1 = contents;\n                        _b.label = 23;\n                    case 23:\n                        if (!(_i < contents_1.length)) return [3 /*break*/, 26];\n                        filename = contents_1[_i];\n                        // Move item from the from directory to the to directory\n                        return [4 /*yield*/, this._copy({\n                                from: from + \"/\" + filename,\n                                to: to + \"/\" + filename,\n                                directory: fromDirectory,\n                                toDirectory: toDirectory,\n                            }, doRename)];\n                    case 24:\n                        // Move item from the from directory to the to directory\n                        _b.sent();\n                        _b.label = 25;\n                    case 25:\n                        _i++;\n                        return [3 /*break*/, 23];\n                    case 26:\n                        if (!doRename) return [3 /*break*/, 28];\n                        return [4 /*yield*/, this.rmdir({\n                                path: from,\n                                directory: fromDirectory\n                            })];\n                    case 27:\n                        _b.sent();\n                        _b.label = 28;\n                    case 28: return [2 /*return*/, {}];\n                }\n            });\n        });\n    };\n    FilesystemPluginWeb._debug = true;\n    return FilesystemPluginWeb;\n}(WebPlugin));\nexport { FilesystemPluginWeb };\nvar Filesystem = new FilesystemPluginWeb();\nexport { Filesystem };\n//# sourceMappingURL=filesystem.js.map"]},"metadata":{},"sourceType":"module"}